; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\User\Desktop\ComputerGraphicsProject\Viewer\DynamicCamera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??1DynamicCamera@@QAE@XZ			; DynamicCamera::~DynamicCamera
PUBLIC	??0DynamicCamera@@QAE@AAVVector@@PAVTerrain@@@Z	; DynamicCamera::DynamicCamera
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	__real@00000000
PUBLIC	??0Matrix@@QAE@XZ				; Matrix::Matrix
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0DynamicCamera@@QAE@XZ			; DynamicCamera::DynamicCamera
EXTRN	__fltused:DWORD
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT __real@00000000
; File c:\users\user\desktop\computergraphicsproject\viewer\dynamiccamera.cpp
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0DynamicCamera@@QAE@XZ
_TEXT	SEGMENT
$T33190 = -332						; size = 104
$T33191 = -220						; size = 12
_this$ = -8						; size = 4
??0DynamicCamera@@QAE@XZ PROC				; DynamicCamera::DynamicCamera, COMDAT
; _this$ = ecx

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0Matrix@@QAE@XZ			; Matrix::Matrix

; 14   : 	DynamicCamera(Vector(0,0,0), NULL);

	push	0
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33191[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T33190[ebp]
	call	??0DynamicCamera@@QAE@AAVVector@@PAVTerrain@@@Z ; DynamicCamera::DynamicCamera
	lea	ecx, DWORD PTR $T33190[ebp]
	call	??1DynamicCamera@@QAE@XZ		; DynamicCamera::~DynamicCamera

; 15   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DynamicCamera@@QAE@XZ ENDP				; DynamicCamera::DynamicCamera
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\user\desktop\computergraphicsproject\viewer\matrix.h
;	COMDAT ??0Matrix@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Matrix@@QAE@XZ PROC					; Matrix::Matrix, COMDAT
; _this$ = ecx

; 23   : 	Matrix()								{ memset(p,0,sizeof(float)*9); }					

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	36					; 00000024H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Matrix@@QAE@XZ ENDP					; Matrix::Matrix
_TEXT	ENDS
EXTRN	?Set@Vector@@QAEXMMM@Z:PROC			; Vector::Set
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\user\desktop\computergraphicsproject\viewer\vector.h
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Vector@@QAE@XZ PROC					; Vector::Vector, COMDAT
; _this$ = ecx

; 20   : 	Vector()								{ Set(0, 0, 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@Vector@@QAEXMMM@Z			; Vector::Set
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0Vector@@QAE@MMM@Z PROC				; Vector::Vector, COMDAT
; _this$ = ecx

; 21   : 	Vector(float _x, float _y, float _z)	{ Set(_x, _y, _z); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __z$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __y$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __x$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@Vector@@QAEXMMM@Z			; Vector::Set
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4136e36000000000
PUBLIC	__real@41100000
PUBLIC	__real@3dcccccd
PUBLIC	__real@42700000
EXTRN	_gluPerspective@32:PROC
EXTRN	?sys_glHeight@@3KA:DWORD			; sys_glHeight
EXTRN	?sys_glWidth@@3KA:DWORD				; sys_glWidth
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	?Identity@Matrix@@QAEXXZ:PROC			; Matrix::Identity
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
;	COMDAT __real@3ff0000000000000
; File c:\users\user\desktop\computergraphicsproject\viewer\dynamiccamera.cpp
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4136e36000000000
CONST	SEGMENT
__real@4136e36000000000 DQ 04136e36000000000r	; 1.5e+006
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0DynamicCamera@@QAE@AAVVector@@PAVTerrain@@@Z
_TEXT	SEGMENT
tv178 = -220						; size = 8
tv174 = -212						; size = 8
_this$ = -8						; size = 4
_vecSrc$ = 8						; size = 4
_land$ = 12						; size = 4
??0DynamicCamera@@QAE@AAVVector@@PAVTerrain@@@Z PROC	; DynamicCamera::DynamicCamera, COMDAT
; _this$ = ecx

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0Matrix@@QAE@XZ			; Matrix::Matrix

; 19   : 	landscape = land;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _land$[ebp]
	mov	DWORD PTR [eax+100], ecx

; 20   : 
; 21   : 	snap = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+36], 0

; 22   : 
; 23   : 	GetCursorPos(&CursorPos);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 24   : 	ShowCursor(false);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__ShowCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 25   : 
; 26   : 	camSrc = vecSrc;

	mov	eax, DWORD PTR _vecSrc$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 27   : 	camAng.Set(0, 0, 0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Set@Vector@@QAEXMMM@Z			; Vector::Set

; 28   : 	viewMat.Identity();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?Identity@Matrix@@QAEXXZ		; Matrix::Identity

; 29   : 
; 30   : 	camFov = 60.f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@42700000
	fstp	DWORD PTR [eax+48]

; 31   : 	camRoll = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+52]

; 32   : 
; 33   : 	angSpeed = 0.1f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@3dcccccd
	fstp	DWORD PTR [eax+40]

; 34   : 	moveSpeed = 9.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@41100000
	fstp	DWORD PTR [eax+44]

; 35   : 
; 36   : 	glMatrixMode (GL_PROJECTION);

	mov	esi, esp
	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 37   : 	glLoadIdentity ();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 38   : 	gluPerspective(camFov, (GLdouble)sys_glWidth/(GLdouble)sys_glHeight, 1.0, 1500000.0);

	sub	esp, 8
	fld	QWORD PTR __real@4136e36000000000
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld1
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR ?sys_glWidth@@3KA	; sys_glWidth
	mov	DWORD PTR tv174[ebp], eax
	mov	DWORD PTR tv174[ebp+4], 0
	fild	QWORD PTR tv174[ebp]
	mov	ecx, DWORD PTR ?sys_glHeight@@3KA	; sys_glHeight
	mov	DWORD PTR tv178[ebp], ecx
	mov	DWORD PTR tv178[ebp+4], 0
	fild	QWORD PTR tv178[ebp]
	fdivp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+48]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_gluPerspective@32

; 39   : 	
; 40   : 	glMatrixMode (GL_MODELVIEW);

	mov	esi, esp
	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 41   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0DynamicCamera@@QAE@AAVVector@@PAVTerrain@@@Z ENDP	; DynamicCamera::DynamicCamera
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??1DynamicCamera@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1DynamicCamera@@QAE@XZ PROC				; DynamicCamera::~DynamicCamera, COMDAT
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1DynamicCamera@@QAE@XZ ENDP				; DynamicCamera::~DynamicCamera
_TEXT	ENDS
PUBLIC	?Update@DynamicCamera@@QAEXXZ			; DynamicCamera::Update
PUBLIC	?SetSnap@DynamicCamera@@QAEX_N@Z		; DynamicCamera::SetSnap
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetSnap@DynamicCamera@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_snap$ = 8						; size = 1
?SetSnap@DynamicCamera@@QAEX_N@Z PROC			; DynamicCamera::SetSnap, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	this->snap = snap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _snap$[ebp]
	mov	BYTE PTR [eax+36], cl

; 50   : 	this->Update();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Update@DynamicCamera@@QAEXXZ		; DynamicCamera::Update

; 51   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSnap@DynamicCamera@@QAEX_N@Z ENDP			; DynamicCamera::SetSnap
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4051800000000000
PUBLIC	_expf
PUBLIC	__real@c000000000000000
EXTRN	__imp__glLoadMatrixf@4:PROC
EXTRN	?GetHeight@Terrain@@QAEMMM@Z:PROC		; Terrain::GetHeight
EXTRN	??ZVector@@QAEXAAV0@@Z:PROC			; Vector::operator-=
EXTRN	??YVector@@QAEXAAV0@@Z:PROC			; Vector::operator+=
EXTRN	??DVector@@QAE?AV0@M@Z:PROC			; Vector::operator*
EXTRN	?kbrd@@3UKeyboard@@A:BYTE			; kbrd
EXTRN	??DMatrix@@QAE?AVVector@@AAV1@@Z:PROC		; Matrix::operator*
EXTRN	?AddRotationY@Matrix@@QAEXM@Z:PROC		; Matrix::AddRotationY
EXTRN	??0Matrix@@QAE@MAAVVector@@@Z:PROC		; Matrix::Matrix
EXTRN	??TVector@@QAE?AV0@AAV0@@Z:PROC			; Vector::operator^
EXTRN	??XVector@@QAEXM@Z:PROC				; Vector::operator*=
EXTRN	?g_frameTime@@3MA:DWORD				; g_frameTime
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4051800000000000
CONST	SEGMENT
__real@4051800000000000 DQ 04051800000000000r	; 70
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Update@DynamicCamera@@QAEXXZ
_TEXT	SEGMENT
tv786 = -656						; size = 4
tv581 = -656						; size = 4
$T33229 = -648						; size = 12
$T33230 = -628						; size = 12
$T33231 = -608						; size = 12
$T33232 = -588						; size = 12
$T33233 = -568						; size = 12
$T33234 = -548						; size = 12
$T33235 = -528						; size = 12
$T33236 = -508						; size = 12
$T33237 = -488						; size = 12
$T33238 = -468						; size = 12
$T33239 = -448						; size = 12
_m$ = -236						; size = 64
_Pos$ = -164						; size = 8
_dy$ = -148						; size = 4
_dx$ = -136						; size = 4
_Rot$ = -124						; size = 36
_dirVec$ = -80						; size = 12
_upVec$ = -60						; size = 12
_sideVec$ = -40						; size = 12
_newAngSpeed$ = -20					; size = 4
_this$ = -8						; size = 4
?Update@DynamicCamera@@QAEXXZ PROC			; DynamicCamera::Update, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-656]
	mov	ecx, 164				; 000000a4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 	float newAngSpeed = angSpeed * g_frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR ?g_frameTime@@3MA		; g_frameTime
	fstp	DWORD PTR _newAngSpeed$[ebp]

; 56   : 
; 57   : 	camAng *= expf(-2.0f*g_frameTime);

	fld	DWORD PTR ?g_frameTime@@3MA		; g_frameTime
	fmul	QWORD PTR __real@c000000000000000
	fstp	DWORD PTR tv581[ebp]
	fld	DWORD PTR tv581[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_expf
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??XVector@@QAEXM@Z			; Vector::operator*=

; 58   : 	camRoll += camAng.z*70;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	fmul	QWORD PTR __real@4051800000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+52]

; 59   : 	
; 60   : 
; 61   : 	// вектор бинормали
; 62   : 	Vector	sideVec(viewMat.p[0], viewMat.p[1], viewMat.p[2]);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+72]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+68]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+64]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _sideVec$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 63   : 	//вектор нормали (указывает "верх" камеры)
; 64   : 	Vector	upVec(viewMat.p[3], viewMat.p[4], viewMat.p[5]);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+84]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+80]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+76]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _upVec$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 65   : 	// вектор направления
; 66   : 	Vector	dirVec(viewMat.p[6], viewMat.p[7], viewMat.p[8]);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+96]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+92]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+88]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _dirVec$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 67   : 	
; 68   : 	// построение матрицы поворота
; 69   : 	Matrix Rot(camAng.y, (dirVec ^ upVec));

	lea	eax, DWORD PTR _upVec$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T33229[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dirVec$[ebp]
	call	??TVector@@QAE?AV0@AAV0@@Z		; Vector::operator^
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+28]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _Rot$[ebp]
	call	??0Matrix@@QAE@MAAVVector@@@Z		; Matrix::Matrix

; 70   : 	// добавление вращения по оси Y (он указывает верх камеры), которое зависит от смещение мыши по х
; 71   : 	Rot.AddRotationY(camAng.x);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _Rot$[ebp]
	call	?AddRotationY@Matrix@@QAEXM@Z		; Matrix::AddRotationY

; 72   : 	// обновление векторов камеры (домножение на матрицу поворота)
; 73   : 	upVec = Rot * upVec;

	lea	eax, DWORD PTR _upVec$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T33230[ebp]
	push	ecx
	lea	ecx, DWORD PTR _Rot$[ebp]
	call	??DMatrix@@QAE?AVVector@@AAV1@@Z	; Matrix::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _upVec$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _upVec$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _upVec$[ebp+8], edx

; 74   : 	dirVec = Rot * dirVec;

	lea	eax, DWORD PTR _dirVec$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T33231[ebp]
	push	ecx
	lea	ecx, DWORD PTR _Rot$[ebp]
	call	??DMatrix@@QAE?AVVector@@AAV1@@Z	; Matrix::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _dirVec$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dirVec$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _dirVec$[ebp+8], edx

; 75   : 	sideVec = Rot * sideVec;

	lea	eax, DWORD PTR _sideVec$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T33232[ebp]
	push	ecx
	lea	ecx, DWORD PTR _Rot$[ebp]
	call	??DMatrix@@QAE?AVVector@@AAV1@@Z	; Matrix::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _sideVec$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _sideVec$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _sideVec$[ebp+8], edx

; 76   : 	// обновление матрицы камеры
; 77   : 	viewMat.p[0] = sideVec.x; viewMat.p[1] = sideVec.y; viewMat.p[2] = sideVec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _sideVec$[ebp]
	fstp	DWORD PTR [eax+64]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _sideVec$[ebp+4]
	fstp	DWORD PTR [eax+68]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _sideVec$[ebp+8]
	fstp	DWORD PTR [eax+72]

; 78   : 	viewMat.p[3] = upVec.x; viewMat.p[4] = upVec.y; viewMat.p[5] = upVec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _upVec$[ebp]
	fstp	DWORD PTR [eax+76]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _upVec$[ebp+4]
	fstp	DWORD PTR [eax+80]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _upVec$[ebp+8]
	fstp	DWORD PTR [eax+84]

; 79   : 	viewMat.p[6] = dirVec.x; viewMat.p[7] = dirVec.y; viewMat.p[8] = dirVec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _dirVec$[ebp]
	fstp	DWORD PTR [eax+88]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _dirVec$[ebp+4]
	fstp	DWORD PTR [eax+92]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _dirVec$[ebp+8]
	fstp	DWORD PTR [eax+96]

; 80   : 
; 81   : 
; 82   : 
; 83   : 	LONG dx, dy;
; 84   : 
; 85   : 	POINT Pos;
; 86   : 	GetCursorPos(&Pos);

	mov	esi, esp
	lea	eax, DWORD PTR _Pos$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 87   : 	dx = Pos.x - CursorPos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Pos$[ebp]
	sub	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _dx$[ebp], ecx

; 88   : 	dy = Pos.y - CursorPos.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Pos$[ebp+4]
	sub	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _dy$[ebp], ecx

; 89   : 	CursorPos = Pos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _Pos$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	edx, DWORD PTR _Pos$[ebp+4]
	mov	DWORD PTR [eax+60], edx

; 90   : 	
; 91   : 	if ((dx != 0) || (dy != 0))

	cmp	DWORD PTR _dx$[ebp], 0
	jne	SHORT $LN14@Update
	cmp	DWORD PTR _dy$[ebp], 0
	je	SHORT $LN15@Update
$LN14@Update:

; 92   : 	{
; 93   : 		/*RECT Screen;
; 94   : 		GetClientRect(GetForegroundWindow(), &Screen);
; 95   : 		POINT center;
; 96   : 		CursorPos.x = Screen.right / 2;
; 97   : 		CursorPos.y = Screen.bottom / 2;
; 98   : 		ClientToScreen(GetForegroundWindow(), &CursorPos);
; 99   : 		SetCursorPos(CursorPos.x, CursorPos.y); */
; 100  : 
; 101  : 		camAng.x -= newAngSpeed * dx / 4;

	fild	DWORD PTR _dx$[ebp]
	fmul	DWORD PTR _newAngSpeed$[ebp]
	fdiv	QWORD PTR __real@4010000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+24]

; 102  : 		camAng.y -= newAngSpeed * dy / 4;

	fild	DWORD PTR _dy$[ebp]
	fmul	DWORD PTR _newAngSpeed$[ebp]
	fdiv	QWORD PTR __real@4010000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [eax+28]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+28]
$LN15@Update:

; 103  : 	}
; 104  : 	
; 105  : 
; 106  : 	if (kbrd.KeyDown[VK_RIGHT] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+39
	cmp	eax, 1
	jne	SHORT $LN13@Update

; 107  : 		camAng.x -= newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	fsub	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+24]
$LN13@Update:

; 108  : 	if (kbrd.KeyDown[VK_LEFT] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+37
	cmp	eax, 1
	jne	SHORT $LN12@Update

; 109  : 		camAng.x += newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+24]
	fadd	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+24]
$LN12@Update:

; 110  : 
; 111  : 	if (kbrd.KeyDown[VK_UP] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+38
	cmp	eax, 1
	jne	SHORT $LN11@Update

; 112  : 		camAng.y += newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+28]
	fadd	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+28]
$LN11@Update:

; 113  : 	if (kbrd.KeyDown[VK_DOWN] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+40
	cmp	eax, 1
	jne	SHORT $LN10@Update

; 114  : 		camAng.y -= newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+28]
	fsub	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+28]
$LN10@Update:

; 115  : 
; 116  : 	// forward-backward
; 117  : 	if (kbrd.KeyDown[87] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+87
	cmp	eax, 1
	jne	SHORT $LN9@Update

; 118  : 		camVel += dirVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33233[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dirVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??YVector@@QAEXAAV0@@Z			; Vector::operator+=
$LN9@Update:

; 119  : 	if (kbrd.KeyDown[83] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+83
	cmp	eax, 1
	jne	SHORT $LN8@Update

; 120  : 		camVel -= dirVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33234[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dirVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??ZVector@@QAEXAAV0@@Z			; Vector::operator-=
$LN8@Update:

; 121  : 
; 122  : 	// left-right
; 123  : 	if (kbrd.KeyDown[68] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+68
	cmp	eax, 1
	jne	SHORT $LN7@Update

; 124  : 		camVel += sideVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33235[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sideVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??YVector@@QAEXAAV0@@Z			; Vector::operator+=
$LN7@Update:

; 125  : 	if (kbrd.KeyDown[65] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+65
	cmp	eax, 1
	jne	SHORT $LN6@Update

; 126  : 		camVel -= sideVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33236[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sideVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??ZVector@@QAEXAAV0@@Z			; Vector::operator-=
$LN6@Update:

; 127  : 
; 128  : 	// up-down
; 129  : 	if (kbrd.KeyDown[81] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+81
	cmp	eax, 1
	jne	SHORT $LN5@Update

; 130  : 		camVel += upVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33237[ebp]
	push	ecx
	lea	ecx, DWORD PTR _upVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??YVector@@QAEXAAV0@@Z			; Vector::operator+=
$LN5@Update:

; 131  : 	if (kbrd.KeyDown[69] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+69
	cmp	eax, 1
	jne	SHORT $LN4@Update

; 132  : 		camVel -= upVec*moveSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T33238[ebp]
	push	ecx
	lea	ecx, DWORD PTR _upVec$[ebp]
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??ZVector@@QAEXAAV0@@Z			; Vector::operator-=
$LN4@Update:

; 133  : 
; 134  : 	//roll
; 135  : 	if (kbrd.KeyDown[45] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+45
	cmp	eax, 1
	jne	SHORT $LN3@Update

; 136  : 		camAng.z -= newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	fsub	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]
$LN3@Update:

; 137  : 	if (kbrd.KeyDown[46] == true)

	movzx	eax, BYTE PTR ?kbrd@@3UKeyboard@@A+46
	cmp	eax, 1
	jne	SHORT $LN2@Update

; 138  : 		camAng.z += newAngSpeed;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+32]
	fadd	DWORD PTR _newAngSpeed$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+32]
$LN2@Update:

; 139  : 
; 140  : 	camSrc += camVel * g_frameTime;

	push	ecx
	fld	DWORD PTR ?g_frameTime@@3MA		; g_frameTime
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T33239[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??DVector@@QAE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??YVector@@QAEXAAV0@@Z			; Vector::operator+=

; 141  : 	if (snap && (camSrc.y < landscape->GetHeight(camSrc.x, camSrc.z) + 5))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN1@Update
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	call	?GetHeight@Terrain@@QAEMMM@Z		; Terrain::GetHeight
	fadd	QWORD PTR __real@4014000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@Update

; 142  : 	{
; 143  : 		camSrc.y = landscape->GetHeight(camSrc.x, camSrc.z) + 5;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	call	?GetHeight@Terrain@@QAEMMM@Z		; Terrain::GetHeight
	fadd	QWORD PTR __real@4014000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]
$LN1@Update:

; 144  : 		/*viewMat.p[0] = sideVec.x;
; 145  : 		viewMat.p[1] = sideVec.y;
; 146  : 		viewMat.p[2] = sideVec.z;
; 147  : 
; 148  : 		viewMat.p[3] = upVec.x;
; 149  : 		viewMat.p[4] = upVec.y;
; 150  : 		viewMat.p[5] = upVec.z;
; 151  : 
; 152  : 		viewMat.p[6] = dirVec.x;
; 153  : 		viewMat.p[7] = dirVec.y;
; 154  : 		viewMat.p[8] = dirVec.z;*/
; 155  : 	}
; 156  : 	camVel *= expf(-2.0f*g_frameTime);

	fld	DWORD PTR ?g_frameTime@@3MA		; g_frameTime
	fmul	QWORD PTR __real@c000000000000000
	fstp	DWORD PTR tv786[ebp]
	fld	DWORD PTR tv786[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	_expf
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??XVector@@QAEXM@Z			; Vector::operator*=

; 157  : 
; 158  : 
; 159  : 	glLoadIdentity ();

	mov	esi, esp
	call	DWORD PTR __imp__glLoadIdentity@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 160  : 
; 161  : 	// обновление матрицы камеры с учетом ее позиции
; 162  : 	float m[16] = {
; 163  : 		viewMat.p[0], viewMat.p[3], -viewMat.p[6], 0,

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	fstp	DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	fstp	DWORD PTR _m$[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+88]
	fchs
	fstp	DWORD PTR _m$[ebp+8]
	fldz
	fstp	DWORD PTR _m$[ebp+12]

; 164  : 		viewMat.p[1], viewMat.p[4], -viewMat.p[7], 0,

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+68]
	fstp	DWORD PTR _m$[ebp+16]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]
	fstp	DWORD PTR _m$[ebp+20]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+92]
	fchs
	fstp	DWORD PTR _m$[ebp+24]
	fldz
	fstp	DWORD PTR _m$[ebp+28]

; 165  : 		viewMat.p[2], viewMat.p[5], -viewMat.p[8], 0,

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+72]
	fstp	DWORD PTR _m$[ebp+32]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+84]
	fstp	DWORD PTR _m$[ebp+36]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+96]
	fchs
	fstp	DWORD PTR _m$[ebp+40]
	fldz
	fstp	DWORD PTR _m$[ebp+44]

; 166  : 		-(viewMat.p[0]*camSrc.x + viewMat.p[1]*camSrc.y + viewMat.p[2]*camSrc.z),

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+68]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR _m$[ebp+48]

; 167  : 		-(viewMat.p[3]*camSrc.x + viewMat.p[4]*camSrc.y + viewMat.p[5]*camSrc.z),

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fchs
	fstp	DWORD PTR _m$[ebp+52]

; 168  : 		 (viewMat.p[6]*camSrc.x + viewMat.p[7]*camSrc.y + viewMat.p[8]*camSrc.z), 

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+88]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+92]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _m$[ebp+56]

; 169  : 		 2
; 170  : 	};

	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR _m$[ebp+60]

; 171  : 
; 172  : 	glLoadMatrixf(m);

	mov	esi, esp
	lea	eax, DWORD PTR _m$[ebp]
	push	eax
	call	DWORD PTR __imp__glLoadMatrixf@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 173  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@Update
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 656				; 00000290H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN25@Update:
	DD	6
	DD	$LN24@Update
$LN24@Update:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN18@Update
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN19@Update
	DD	-80					; ffffffb0H
	DD	12					; 0000000cH
	DD	$LN20@Update
	DD	-124					; ffffff84H
	DD	36					; 00000024H
	DD	$LN21@Update
	DD	-164					; ffffff5cH
	DD	8
	DD	$LN22@Update
	DD	-236					; ffffff14H
	DD	64					; 00000040H
	DD	$LN23@Update
$LN23@Update:
	DB	109					; 0000006dH
	DB	0
$LN22@Update:
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN21@Update:
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN20@Update:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
$LN19@Update:
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
$LN18@Update:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	0
?Update@DynamicCamera@@QAEXXZ ENDP			; DynamicCamera::Update
_TEXT	ENDS
EXTRN	_exp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _expf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_expf	PROC						; COMDAT

; 403  :         {return ((float)exp((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_exp
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_expf	ENDP
_TEXT	ENDS
END
