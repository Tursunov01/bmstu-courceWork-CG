; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\User\Desktop\ComputerGraphicsProject\Viewer\Win32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?hDC@@3PAUHDC__@@A				; hDC
PUBLIC	?sys_glHeight@@3KA				; sys_glHeight
PUBLIC	?kbrd@@3UKeyboard@@A				; kbrd
PUBLIC	?sys_glWidth@@3KA				; sys_glWidth
PUBLIC	?sys_glBPP@@3EA					; sys_glBPP
PUBLIC	?sys_Time@@3KA					; sys_Time
PUBLIC	?glActiveTextureARB@@3P6GXI@ZA			; glActiveTextureARB
PUBLIC	?glMultiTexCoord2fARB@@3P6GXIMM@ZA		; glMultiTexCoord2fARB
PUBLIC	?glClientActiveTextureARB@@3P6GXI@ZA		; glClientActiveTextureARB
PUBLIC	?glLockArraysEXT@@3P6GXHH@ZA			; glLockArraysEXT
PUBLIC	?glUnlockArraysEXT@@3P6GXXZA			; glUnlockArraysEXT
PUBLIC	?glFogCoordfEXT@@3P6GXM@ZA			; glFogCoordfEXT
_BSS	SEGMENT
?hDC@@3PAUHDC__@@A DD 01H DUP (?)			; hDC
?sys_glHeight@@3KA DD 01H DUP (?)			; sys_glHeight
?kbrd@@3UKeyboard@@A DB 0100H DUP (?)			; kbrd
?sys_glWidth@@3KA DD 01H DUP (?)			; sys_glWidth
?sys_glBPP@@3EA DB 01H DUP (?)				; sys_glBPP
	ALIGN	4

?sys_Time@@3KA DD 01H DUP (?)				; sys_Time
?glActiveTextureARB@@3P6GXI@ZA DD 01H DUP (?)		; glActiveTextureARB
?glMultiTexCoord2fARB@@3P6GXIMM@ZA DD 01H DUP (?)	; glMultiTexCoord2fARB
?glClientActiveTextureARB@@3P6GXI@ZA DD 01H DUP (?)	; glClientActiveTextureARB
?glLockArraysEXT@@3P6GXHH@ZA DD 01H DUP (?)		; glLockArraysEXT
?glUnlockArraysEXT@@3P6GXXZA DD 01H DUP (?)		; glUnlockArraysEXT
?glFogCoordfEXT@@3P6GXM@ZA DD 01H DUP (?)		; glFogCoordfEXT
_BSS	ENDS
_DATA	SEGMENT
?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A DW 028H ; `SetDCPixelFormat'::`2'::pfd
	DW	01H
	DD	025H
	DB	00H
	ORG $+31
_DATA	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DebugOut@@YAXPBDZZ				; DebugOut
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__vsnprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\users\user\desktop\computergraphicsproject\viewer\win32.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?DebugOut@@YAXPBDZZ
_TEXT	SEGMENT
_szBuffer$ = -1044					; size = 1024
_argList$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_szFormat$ = 8						; size = 4
?DebugOut@@YAXPBDZZ PROC				; DebugOut, COMDAT

; 24   :   {

	push	ebp
	mov	ebp, esp
	sub	esp, 1240				; 000004d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1240]
	mov	ecx, 310				; 00000136H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 25   :     va_list argList;
; 26   :     char szBuffer[kMaxDebugMessageLength];
; 27   : 
; 28   :     va_start(argList, szFormat);

	lea	eax, DWORD PTR _szFormat$[ebp+4]
	mov	DWORD PTR _argList$[ebp], eax

; 29   :     _vsnprintf(szBuffer, kMaxDebugMessageLength, szFormat, argList);

	mov	eax, DWORD PTR _argList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFormat$[ebp]
	push	ecx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	__vsnprintf
	add	esp, 16					; 00000010H

; 30   :     va_end(argList);

	mov	DWORD PTR _argList$[ebp], 0

; 31   : 
; 32   :     OutputDebugString(szBuffer);

	mov	esi, esp
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 33   :   }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DebugOut
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1240				; 000004d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@DebugOut:
	DD	1
	DD	$LN4@DebugOut
$LN4@DebugOut:
	DD	-1044					; fffffbecH
	DD	1024					; 00000400H
	DD	$LN3@DebugOut
$LN3@DebugOut:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DebugOut@@YAXPBDZZ ENDP				; DebugOut
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?ChangeDisplayMode@@YA_NXZ			; ChangeDisplayMode
EXTRN	__imp__ChangeDisplaySettingsA@8:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ChangeDisplayMode@@YA_NXZ
_TEXT	SEGMENT
_device_mode$ = -164					; size = 156
__$ArrayPad$ = -4					; size = 4
?ChangeDisplayMode@@YA_NXZ PROC				; ChangeDisplayMode, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-360]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 38   : 
; 39   :   DEVMODE device_mode;
; 40   : 
; 41   :   memset(&device_mode, 0, sizeof(DEVMODE));

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _device_mode$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 42   : 
; 43   :   device_mode.dmSize = sizeof(DEVMODE);

	mov	eax, 156				; 0000009cH
	mov	WORD PTR _device_mode$[ebp+36], ax

; 44   : 
; 45   :   device_mode.dmPelsWidth  = sys_glWidth;

	mov	eax, DWORD PTR ?sys_glWidth@@3KA	; sys_glWidth
	mov	DWORD PTR _device_mode$[ebp+108], eax

; 46   :   device_mode.dmPelsHeight = sys_glHeight;

	mov	eax, DWORD PTR ?sys_glHeight@@3KA	; sys_glHeight
	mov	DWORD PTR _device_mode$[ebp+112], eax

; 47   :   if( sys_glBPP )

	movzx	eax, BYTE PTR ?sys_glBPP@@3EA		; sys_glBPP
	test	eax, eax
	je	SHORT $LN4@ChangeDisp

; 48   :   {
; 49   :     device_mode.dmBitsPerPel = sys_glBPP;

	movzx	eax, BYTE PTR ?sys_glBPP@@3EA		; sys_glBPP
	mov	DWORD PTR _device_mode$[ebp+104], eax

; 50   :     device_mode.dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;

	mov	DWORD PTR _device_mode$[ebp+40], 1835008 ; 001c0000H

; 51   :   } else

	jmp	SHORT $LN3@ChangeDisp
$LN4@ChangeDisp:

; 52   :   {
; 53   :     device_mode.dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT;

	mov	DWORD PTR _device_mode$[ebp+40], 1572864 ; 00180000H
$LN3@ChangeDisp:

; 54   :   }
; 55   : 
; 56   :   if( ChangeDisplaySettings(&device_mode, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL )

	mov	esi, esp
	push	4
	lea	eax, DWORD PTR _device_mode$[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@ChangeDisp

; 57   :     return true; 

	mov	al, 1
	jmp	SHORT $LN5@ChangeDisp

; 58   :   else

	jmp	SHORT $LN5@ChangeDisp
$LN2@ChangeDisp:

; 59   :     return false;

	xor	al, al
$LN5@ChangeDisp:

; 60   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@ChangeDisp
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 360				; 00000168H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN9@ChangeDisp:
	DD	1
	DD	$LN8@ChangeDisp
$LN8@ChangeDisp:
	DD	-164					; ffffff5cH
	DD	156					; 0000009cH
	DD	$LN7@ChangeDisp
$LN7@ChangeDisp:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?ChangeDisplayMode@@YA_NXZ ENDP				; ChangeDisplayMode
_TEXT	ENDS
PUBLIC	?RestoreDisplayMode@@YAXXZ			; RestoreDisplayMode
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?RestoreDisplayMode@@YAXXZ
_TEXT	SEGMENT
?RestoreDisplayMode@@YAXXZ PROC				; RestoreDisplayMode, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 64   :   ChangeDisplaySettings(0, 0);

	mov	esi, esp
	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreDisplayMode@@YAXXZ ENDP				; RestoreDisplayMode
_TEXT	ENDS
PUBLIC	??_C@_0CC@DKGNDJAL@PixelFormat?5Selected?3?5?$CFd?6BPP?3?5?$CFd@ ; `string'
PUBLIC	?SetDCPixelFormat@@YAXPAUHDC__@@@Z		; SetDCPixelFormat
EXTRN	__imp__SetPixelFormat@12:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__ChoosePixelFormat@8:PROC
_BSS	SEGMENT
?$S1@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4IA DD 01H DUP (?) ; `SetDCPixelFormat'::`2'::$S1
_BSS	ENDS
;	COMDAT ??_C@_0CC@DKGNDJAL@PixelFormat?5Selected?3?5?$CFd?6BPP?3?5?$CFd@
CONST	SEGMENT
??_C@_0CC@DKGNDJAL@PixelFormat?5Selected?3?5?$CFd?6BPP?3?5?$CFd@ DB 'Pixe'
	DB	'lFormat Selected: %d', 0aH, 'BPP: %d', 0aH, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?SetDCPixelFormat@@YAXPAUHDC__@@@Z
_TEXT	SEGMENT
_nPixelFormat$ = -8					; size = 4
_hDC$ = 8						; size = 4
?SetDCPixelFormat@@YAXPAUHDC__@@@Z PROC			; SetDCPixelFormat, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 70   : 
; 71   :   int nPixelFormat;
; 72   : 
; 73   :   static PIXELFORMATDESCRIPTOR pfd = {
; 74   :     sizeof(PIXELFORMATDESCRIPTOR),  // Size of this structure
; 75   :     1,                              // Version of this structure
; 76   :     PFD_DRAW_TO_WINDOW |    // Draw to Window (not to bitmap)
; 77   :     PFD_SUPPORT_OPENGL |    // Support OpenGL calls in window
; 78   :     PFD_DOUBLEBUFFER,       // Double buffered mode
; 79   :     PFD_TYPE_RGBA,        // RGBA Color mode
; 80   :     sys_glBPP,  // Want the display bit depth

	mov	eax, DWORD PTR ?$S1@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4IA
	and	eax, 1
	jne	$LN1@SetDCPixel
	mov	eax, DWORD PTR ?$S1@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4IA
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4IA, eax
	mov	al, BYTE PTR ?sys_glBPP@@3EA		; sys_glBPP
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+9, al

; 81   :     0,0,0,0,0,0,                    // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+10, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+11, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+12, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+13, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+14, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+15, 0

; 82   :     0,0,                            // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+16, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+17, 0

; 83   :     0,0,0,0,0,                      // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+18, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+19, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+20, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+21, 0
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+22, 0

; 84   :     sys_glBPP,  // Size of depth buffer should match BPP.

	mov	al, BYTE PTR ?sys_glBPP@@3EA		; sys_glBPP
	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+23, al

; 85   :     0,                    // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+24, 0

; 86   :     0,                    // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+25, 0

; 87   :     PFD_MAIN_PLANE,       // Draw in main plane

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+26, 0

; 88   :     0,                    // Not used to select mode

	mov	BYTE PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+27, 0

; 89   :     0,0,0

	mov	DWORD PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+28, 0
	mov	DWORD PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+32, 0

; 90   :   };                      // Not used to select mode

	mov	DWORD PTR ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A+36, 0
$LN1@SetDCPixel:

; 91   : 
; 92   :   nPixelFormat = ChoosePixelFormat(hDC, &pfd);

	mov	esi, esp
	push	OFFSET ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__ChoosePixelFormat@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nPixelFormat$[ebp], eax

; 93   :   DebugOut( "PixelFormat Selected: %d\nBPP: %d\n", nPixelFormat, GetDeviceCaps(hDC, BITSPIXEL) );

	mov	esi, esp
	push	12					; 0000000cH
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _nPixelFormat$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CC@DKGNDJAL@PixelFormat?5Selected?3?5?$CFd?6BPP?3?5?$CFd@
	call	?DebugOut@@YAXPBDZZ			; DebugOut
	add	esp, 12					; 0000000cH

; 94   : 
; 95   :   SetPixelFormat(hDC, nPixelFormat, &pfd);

	mov	esi, esp
	push	OFFSET ?pfd@?1??SetDCPixelFormat@@YAXPAUHDC__@@@Z@4UtagPIXELFORMATDESCRIPTOR@@A
	mov	eax, DWORD PTR _nPixelFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hDC$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetPixelFormat@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDCPixelFormat@@YAXPAUHDC__@@@Z ENDP			; SetDCPixelFormat
_TEXT	ENDS
PUBLIC	?ChangeSize@@YAXHH@Z				; ChangeSize
EXTRN	__imp__glViewport@16:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ChangeSize@@YAXHH@Z
_TEXT	SEGMENT
_w$ = 8							; size = 4
_h$ = 12						; size = 4
?ChangeSize@@YAXHH@Z PROC				; ChangeSize, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 100  :   if (h == 0)

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN1@ChangeSize

; 101  :     h = 1;

	mov	DWORD PTR _h$[ebp], 1
$LN1@ChangeSize:

; 102  : 
; 103  :   glViewport(0, 0, w, h);

	mov	esi, esp
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__glViewport@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeSize@@YAXHH@Z ENDP				; ChangeSize
_TEXT	ENDS
PUBLIC	??_C@_0BK@JLJCMPDA@App?5failed?5to?5initialize?4?$AA@ ; `string'
PUBLIC	??_C@_0CL@MGLGOHEK@App?5failed?5to?5create?5the?5renderi@ ; `string'
PUBLIC	??_C@_0ED@FJHKELEI@Error?5creating?5the?5window?5class?0@ ; `string'
PUBLIC	??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@		; `string'
PUBLIC	??_C@_0L@ODLGJNHE@OGLC_Class?$AA@		; `string'
PUBLIC	?OGLCProc@@YGJPAUHWND__@@IIJ@Z			; OGLCProc
PUBLIC	??_C@_0DP@MGIJGOBI@App?5returned?5false?5on?5PreInit?$CI?$CJ?0@ ; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0O@BKGKKCED@?9fullscreen?$DN0?$AA@	; `string'
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	??_C@_0M@POMOHKFL@?9fullscreen?$AA@		; `string'
PUBLIC	_WinMain@16
EXTRN	__imp__SwapBuffers@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	?appRender@@YA_NXZ:PROC				; appRender
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	?appInitGL@@YA_NXZ:PROC				; appInitGL
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	?appGetTitleBar@@YAPADXZ:PROC			; appGetTitleBar
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	?appPreInit@@YA_NXZ:PROC			; appPreInit
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
_BSS	SEGMENT
_TimeStart DQ	01H DUP (?)
_TimeFreq DQ	01H DUP (?)
_oglcHeight DD	01H DUP (?)
_oglcWidth DD	01H DUP (?)
_oglcFullscreen DB 01H DUP (?)
	ALIGN	4

_bReady	DB	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BK@JLJCMPDA@App?5failed?5to?5initialize?4?$AA@
CONST	SEGMENT
??_C@_0BK@JLJCMPDA@App?5failed?5to?5initialize?4?$AA@ DB 'App failed to i'
	DB	'nitialize.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MGLGOHEK@App?5failed?5to?5create?5the?5renderi@
CONST	SEGMENT
??_C@_0CL@MGLGOHEK@App?5failed?5to?5create?5the?5renderi@ DB 'App failed '
	DB	'to create the rendering window.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FJHKELEI@Error?5creating?5the?5window?5class?0@
CONST	SEGMENT
??_C@_0ED@FJHKELEI@Error?5creating?5the?5window?5class?0@ DB 'Error creat'
	DB	'ing the window class, right before creating the window.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@
CONST	SEGMENT
??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@ DB 'Fatal Blow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODLGJNHE@OGLC_Class?$AA@
CONST	SEGMENT
??_C@_0L@ODLGJNHE@OGLC_Class?$AA@ DB 'OGLC_Class', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MGIJGOBI@App?5returned?5false?5on?5PreInit?$CI?$CJ?0@
CONST	SEGMENT
??_C@_0DP@MGIJGOBI@App?5returned?5false?5on?5PreInit?$CI?$CJ?0@ DB 'App r'
	DB	'eturned false on PreInit(), we shouldn''t really continue.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKGKKCED@?9fullscreen?$DN0?$AA@
CONST	SEGMENT
??_C@_0O@BKGKKCED@?9fullscreen?$DN0?$AA@ DB '-fullscreen=0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POMOHKFL@?9fullscreen?$AA@
CONST	SEGMENT
??_C@_0M@POMOHKFL@?9fullscreen?$AA@ DB '-fullscreen', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_hDC$32821 = -144					; size = 4
_TimeNow$32819 = -132					; size = 8
_msg$ = -116						; size = 28
_bGotMsg$ = -80						; size = 4
_hWnd$ = -68						; size = 4
_wc$ = -56						; size = 40
_hDC$ = -8						; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 112  :   // Say we're not ready to render yet.
; 113  :   bReady = false;

	mov	BYTE PTR _bReady, 0

; 114  : 
; 115  :   // Load up our system settings from OpenGLChallenge.INI
; 116  : 	oglcFullscreen = false;

	mov	BYTE PTR _oglcFullscreen, 0

; 117  : 	//oglcFullscreen = true;
; 118  : 	oglcWidth = 800;

	mov	DWORD PTR _oglcWidth, 800		; 00000320H

; 119  : 	oglcHeight = 600;

	mov	DWORD PTR _oglcHeight, 600		; 00000258H

; 120  : 
; 121  : 	HDC hDC = GetDC( 0 ); // Get the screen's DC.

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hDC$[ebp], eax

; 122  : 	sys_glBPP = GetDeviceCaps(hDC, BITSPIXEL);

	mov	esi, esp
	push	12					; 0000000cH
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR ?sys_glBPP@@3EA, al		; sys_glBPP

; 123  : 	ReleaseDC( 0, hDC);

	mov	esi, esp
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 124  : 
; 125  :   // Command line can override.
; 126  :   if (strstr(lpCmdLine, "-fullscreen"))

	push	OFFSET ??_C@_0M@POMOHKFL@?9fullscreen?$AA@
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@WinMain

; 127  :     oglcFullscreen = true;

	mov	BYTE PTR _oglcFullscreen, 1
$LN13@WinMain:

; 128  :   if (strstr(lpCmdLine, "-fullscreen=0"))

	push	OFFSET ??_C@_0O@BKGKKCED@?9fullscreen?$DN0?$AA@
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@WinMain

; 129  :     oglcFullscreen = false;

	mov	BYTE PTR _oglcFullscreen, 0
$LN12@WinMain:

; 130  : 
; 131  :   //-------------------------------------------------------------------
; 132  :   // Preinitialize the app.
; 133  :   if( appPreInit() == false )

	call	?appPreInit@@YA_NXZ			; appPreInit
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@WinMain

; 134  :   {
; 135  :     MessageBox( NULL, "App returned false on PreInit(), we shouldn't really continue.", "Error", MB_OK | MB_ICONERROR );

	mov	esi, esp
	push	16					; 00000010H
	push	OFFSET ??_C@_05NAOIJFC@Error?$AA@
	push	OFFSET ??_C@_0DP@MGIJGOBI@App?5returned?5false?5on?5PreInit?$CI?$CJ?0@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 136  :     return FALSE; // Quit right away.

	xor	eax, eax
	jmp	$LN14@WinMain
$LN11@WinMain:

; 137  :   }
; 138  : 
; 139  :   // Specify exactly what the app dimensions should be..
; 140  :   sys_glWidth = oglcWidth;

	mov	eax, DWORD PTR _oglcWidth
	mov	DWORD PTR ?sys_glWidth@@3KA, eax	; sys_glWidth

; 141  :   sys_glHeight = oglcHeight;

	mov	eax, DWORD PTR _oglcHeight
	mov	DWORD PTR ?sys_glHeight@@3KA, eax	; sys_glHeight

; 142  : 
; 143  : 
; 144  :   // Setup the window class.
; 145  :   WNDCLASS wc;
; 146  :   HWND hWnd;
; 147  :   wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;

	mov	DWORD PTR _wc$[ebp], 35			; 00000023H

; 148  :   wc.lpfnWndProc  = (WNDPROC)OGLCProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET ?OGLCProc@@YGJPAUHWND__@@IIJ@Z ; OGLCProc

; 149  :   wc.cbClsExtra = 0;

	mov	DWORD PTR _wc$[ebp+8], 0

; 150  :   wc.cbWndExtra = 0;

	mov	DWORD PTR _wc$[ebp+12], 0

; 151  :   wc.hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 152  :   wc.hIcon = NULL;

	mov	DWORD PTR _wc$[ebp+20], 0

; 153  :   wc.hCursor = LoadCursor( NULL, IDC_ARROW );

	mov	esi, esp
	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wc$[ebp+24], eax

; 154  : 
; 155  :   wc.hbrBackground = NULL;

	mov	DWORD PTR _wc$[ebp+28], 0

; 156  :   wc.lpszMenuName = NULL;

	mov	DWORD PTR _wc$[ebp+32], 0

; 157  :   wc.lpszClassName = "OGLC_Class";

	mov	DWORD PTR _wc$[ebp+36], OFFSET ??_C@_0L@ODLGJNHE@OGLC_Class?$AA@

; 158  : 
; 159  :   // Announce it to the Microsloth OS.
; 160  :   if( RegisterClass( &wc ) == 0)

	mov	esi, esp
	lea	eax, DWORD PTR _wc$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN10@WinMain

; 161  :   {
; 162  :     MessageBox( NULL, "Error creating the window class, right before creating the window.", "Fatal Blow", MB_OK | MB_ICONERROR );

	mov	esi, esp
	push	16					; 00000010H
	push	OFFSET ??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@
	push	OFFSET ??_C@_0ED@FJHKELEI@Error?5creating?5the?5window?5class?0@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 163  :     return FALSE; // Failed to create window, so just quit right away.

	xor	eax, eax
	jmp	$LN14@WinMain
$LN10@WinMain:

; 164  :   }
; 165  : 
; 166  :   // Make it go.......
; 167  :   if( oglcFullscreen == false )

	movzx	eax, BYTE PTR _oglcFullscreen
	test	eax, eax
	jne	SHORT $LN9@WinMain

; 168  :   { // Default startup mode.
; 169  :     hWnd = CreateWindow("OGLC_Class",
; 170  :                         appGetTitleBar(),
; 171  :                         WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN|WS_CLIPSIBLINGS,
; 172  :                         CW_USEDEFAULT, CW_USEDEFAULT,
; 173  :                         oglcWidth, oglcHeight,
; 174  :                         NULL, NULL,
; 175  :                         hInstance,
; 176  :                         NULL );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _oglcHeight
	push	ecx
	mov	edx, DWORD PTR _oglcWidth
	push	edx
	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	114229248				; 06cf0000H
	call	?appGetTitleBar@@YAPADXZ		; appGetTitleBar
	push	eax
	push	OFFSET ??_C@_0L@ODLGJNHE@OGLC_Class?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hWnd$[ebp], eax

; 177  :   } else

	jmp	SHORT $LN8@WinMain
$LN9@WinMain:

; 178  :   { // alternate startup mode, to bring up full screen.
; 179  :     hWnd = CreateWindow("OGLC_Class",
; 180  :                         appGetTitleBar(),
; 181  :                         WS_POPUP,
; 182  :                         0, 0,
; 183  :                         oglcWidth, oglcHeight,
; 184  :                         NULL, NULL,
; 185  :                         hInstance,
; 186  :                         NULL );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _oglcHeight
	push	ecx
	mov	edx, DWORD PTR _oglcWidth
	push	edx
	push	0
	push	0
	push	-2147483648				; 80000000H
	call	?appGetTitleBar@@YAPADXZ		; appGetTitleBar
	push	eax
	push	OFFSET ??_C@_0L@ODLGJNHE@OGLC_Class?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hWnd$[ebp], eax
$LN8@WinMain:

; 187  :   }
; 188  : 
; 189  :   if( hWnd == NULL )

	cmp	DWORD PTR _hWnd$[ebp], 0
	jne	SHORT $LN7@WinMain

; 190  :   {
; 191  :     MessageBox( NULL, "App failed to create the rendering window.", "Fatal Blow", MB_OK | MB_ICONERROR );

	mov	esi, esp
	push	16					; 00000010H
	push	OFFSET ??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@
	push	OFFSET ??_C@_0CL@MGLGOHEK@App?5failed?5to?5create?5the?5renderi@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 192  :     return FALSE; // Failed to create window, so just quit right away.

	xor	eax, eax
	jmp	$LN14@WinMain
$LN7@WinMain:

; 193  :   }
; 194  : 
; 195  :   // Make the app window visible...
; 196  :   ShowWindow( hWnd, SW_SHOW );

	mov	esi, esp
	push	5
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 197  :   UpdateWindow( hWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__UpdateWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 198  : 
; 199  :   // Initialize our system time.
; 200  :   QueryPerformanceFrequency(&TimeFreq);

	mov	esi, esp
	push	OFFSET _TimeFreq
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 201  :   QueryPerformanceCounter(&TimeStart);

	mov	esi, esp
	push	OFFSET _TimeStart
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 202  : 
; 203  :   // Prepare the scene for rendering.
; 204  :   if( appInitGL() == false )

	call	?appInitGL@@YA_NXZ			; appInitGL
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@WinMain

; 205  :   {
; 206  :     MessageBox( hWnd, "App failed to initialize.", "Fatal Blow", MB_OK | MB_ICONERROR );

	mov	esi, esp
	push	16					; 00000010H
	push	OFFSET ??_C@_0L@BOCCMDBE@Fatal?5Blow?$AA@
	push	OFFSET ??_C@_0BK@JLJCMPDA@App?5failed?5to?5initialize?4?$AA@
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 207  :     return FALSE; // Failed init, so just quit right away.

	xor	eax, eax
	jmp	$LN14@WinMain
$LN6@WinMain:

; 208  :   }
; 209  : 
; 210  :   // Turn on the title update timer.
; 211  :   // - Put in .5 second timer for title update code.
; 212  :   SetTimer( hWnd, TIMER_CODE, 500, 0 );

	mov	esi, esp
	push	0
	push	500					; 000001f4H
	push	123					; 0000007bH
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SetTimer@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 213  : 
; 214  :   // We're now ready.
; 215  :   bReady = true;

	mov	BYTE PTR _bReady, 1

; 216  : 
; 217  :   // Usual running around in circles bit...
; 218  :   BOOL bGotMsg;
; 219  :   MSG  msg;
; 220  :   PeekMessage( &msg, NULL, 0U, 0U, PM_NOREMOVE );

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@WinMain:

; 221  :   while( WM_QUIT != msg.message  )

	cmp	DWORD PTR _msg$[ebp+4], 18		; 00000012H
	je	$LN4@WinMain

; 222  :   {
; 223  :     // Use PeekMessage() if the app is active, so we can use idle time to
; 224  :     // render the scene. Else, use GetMessage() to avoid eating CPU time.
; 225  :     bGotMsg = PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE );

	mov	esi, esp
	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bGotMsg$[ebp], eax

; 226  : 
; 227  :     if( bGotMsg )

	cmp	DWORD PTR _bGotMsg$[ebp], 0
	je	SHORT $LN3@WinMain

; 228  :     {
; 229  :       // Translate and dispatch the message
; 230  :       TranslateMessage( &msg );

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  :       DispatchMessage( &msg );

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 232  :     }
; 233  :     else

	jmp	$LN2@WinMain
$LN3@WinMain:

; 234  :     {
; 235  :       // Get the current time, and update the time controller.
; 236  :       LARGE_INTEGER TimeNow;
; 237  :       QueryPerformanceCounter(&TimeNow);

	mov	esi, esp
	lea	eax, DWORD PTR _TimeNow$32819[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 238  :       sys_Time = (UInt32)((TimeNow.QuadPart-TimeStart.QuadPart)*1000/TimeFreq.QuadPart);

	mov	eax, DWORD PTR _TimeNow$32819[ebp]
	sub	eax, DWORD PTR _TimeStart
	mov	ecx, DWORD PTR _TimeNow$32819[ebp+4]
	sbb	ecx, DWORD PTR _TimeStart+4
	push	0
	push	1000					; 000003e8H
	push	ecx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _TimeFreq+4
	push	ecx
	mov	ecx, DWORD PTR _TimeFreq
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR ?sys_Time@@3KA, eax		; sys_Time

; 239  : 
; 240  :       HDC hDC = GetDC( hWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hDC$32821[ebp], eax

; 241  : 
; 242  :       // Draw all the scene related stuff.
; 243  :       if( appRender() == false )

	call	?appRender@@YA_NXZ			; appRender
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@WinMain

; 244  :         DestroyWindow(hWnd); // False means quit.

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@WinMain:

; 245  : 
; 246  :       // Make it all visible at once!
; 247  :       SwapBuffers( hDC );

	mov	esi, esp
	mov	eax, DWORD PTR _hDC$32821[ebp]
	push	eax
	call	DWORD PTR __imp__SwapBuffers@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 248  : 
; 249  :       ReleaseDC(hWnd, hDC );

	mov	esi, esp
	mov	eax, DWORD PTR _hDC$32821[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@WinMain:

; 250  :     }
; 251  :   }

	jmp	$LN5@WinMain
$LN4@WinMain:

; 252  : 
; 253  :   // Not ready to render anymore.
; 254  :   bReady = false;

	mov	BYTE PTR _bReady, 0

; 255  : 
; 256  :   return msg.wParam;

	mov	eax, DWORD PTR _msg$[ebp+8]
$LN14@WinMain:

; 257  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@WinMain
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN20@WinMain:
	DD	3
	DD	$LN19@WinMain
$LN19@WinMain:
	DD	-56					; ffffffc8H
	DD	40					; 00000028H
	DD	$LN16@WinMain
	DD	-116					; ffffff8cH
	DD	28					; 0000001cH
	DD	$LN17@WinMain
	DD	-132					; ffffff7cH
	DD	8
	DD	$LN18@WinMain
$LN18@WinMain:
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN17@WinMain:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
$LN16@WinMain:
	DB	119					; 00000077H
	DB	99					; 00000063H
	DB	0
_WinMain@16 ENDP
_TEXT	ENDS
EXTRN	_strstr:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __SubStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strstr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
PUBLIC	?isExtensionSupported@@YAHPBD@Z			; isExtensionSupported
EXTRN	_strlen:PROC
EXTRN	__imp__glGetString@4:PROC
EXTRN	_strchr:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\user\desktop\computergraphicsproject\viewer\win32.cpp
;	COMDAT ?isExtensionSupported@@YAHPBD@Z
_TEXT	SEGMENT
_terminator$ = -44					; size = 4
_where$ = -32						; size = 4
_start$ = -20						; size = 4
_extensions$ = -8					; size = 4
_extension$ = 8						; size = 4
?isExtensionSupported@@YAHPBD@Z PROC			; isExtensionSupported, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 274  : 	const GLubyte *extensions = NULL;

	mov	DWORD PTR _extensions$[ebp], 0

; 275  : 	const GLubyte *start;
; 276  : 	GLubyte *where, *terminator;
; 277  : 
; 278  : 	/* Extension names should not have spaces. */
; 279  : 	where = (GLubyte *) strchr(extension, ' ');

	push	32					; 00000020H
	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _where$[ebp], eax

; 280  : 	if (where || *extension == '\0')

	cmp	DWORD PTR _where$[ebp], 0
	jne	SHORT $LN8@isExtensio
	mov	eax, DWORD PTR _extension$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@isExtensio
$LN8@isExtensio:

; 281  : 		return 0;

	xor	eax, eax
	jmp	$LN10@isExtensio
$LN9@isExtensio:

; 282  : 	extensions = glGetString(GL_EXTENSIONS);

	mov	esi, esp
	push	7939					; 00001f03H
	call	DWORD PTR __imp__glGetString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _extensions$[ebp], eax

; 283  : 	/* It takes a bit of care to be fool-proof about parsing the
; 284  : 	 OpenGL extensions string. Don't be fooled by sub-strings,
; 285  : 	 etc. */
; 286  : 	start = extensions;

	mov	eax, DWORD PTR _extensions$[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN7@isExtensio:

; 287  : 	for (;;) 
; 288  : 	{
; 289  : 		where = (GLubyte *) strstr((const char *) start, extension);

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	_strstr
	add	esp, 8
	mov	DWORD PTR _where$[ebp], eax

; 290  : 		if (!where)

	cmp	DWORD PTR _where$[ebp], 0
	jne	SHORT $LN5@isExtensio

; 291  : 			break;

	jmp	SHORT $LN6@isExtensio
$LN5@isExtensio:

; 292  : 		terminator = where + strlen(extension);

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _where$[ebp]
	mov	DWORD PTR _terminator$[ebp], eax

; 293  : 		if (where == start || *(where - 1) == ' ')

	mov	eax, DWORD PTR _where$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	je	SHORT $LN3@isExtensio
	mov	eax, DWORD PTR _where$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN4@isExtensio
$LN3@isExtensio:

; 294  : 			if (*terminator == ' ' || *terminator == '\0')

	mov	eax, DWORD PTR _terminator$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN1@isExtensio
	mov	eax, DWORD PTR _terminator$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@isExtensio
$LN1@isExtensio:

; 295  : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN10@isExtensio
$LN4@isExtensio:

; 296  : 		start = terminator;

	mov	eax, DWORD PTR _terminator$[ebp]
	mov	DWORD PTR _start$[ebp], eax

; 297  : 	}

	jmp	SHORT $LN7@isExtensio
$LN6@isExtensio:

; 298  : 	return 0;

	xor	eax, eax
$LN10@isExtensio:

; 299  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isExtensionSupported@@YAHPBD@Z ENDP			; isExtensionSupported
_TEXT	ENDS
PUBLIC	??_C@_0BC@CIFHOEOG@glUnlockArraysEXT?$AA@	; `string'
PUBLIC	??_C@_0BA@FALFDEFM@glLockArraysEXT?$AA@		; `string'
PUBLIC	??_C@_0DK@NGGABOKH@EXT_compiled_vertex_array?5is?5not@ ; `string'
PUBLIC	??_C@_0BN@LBNKGIPJ@GL_EXT_compiled_vertex_array?$AA@ ; `string'
PUBLIC	??_C@_0P@HILEJHGE@glFogCoordfEXT?$AA@		; `string'
PUBLIC	??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB?$AA@ ; `string'
PUBLIC	??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB?$AA@	; `string'
PUBLIC	??_C@_0BD@IKCKKKNH@glActiveTextureARB?$AA@	; `string'
PUBLIC	??_C@_0DB@FCDBIGHN@ARB_multitexture?5is?5not?5supporte@ ; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0BE@MEMOPMEA@GL_ARB_multitexture?$AA@	; `string'
PUBLIC	?InitExtensions@@YAXXZ				; InitExtensions
EXTRN	__imp__wglGetProcAddress@4:PROC
;	COMDAT ??_C@_0BC@CIFHOEOG@glUnlockArraysEXT?$AA@
CONST	SEGMENT
??_C@_0BC@CIFHOEOG@glUnlockArraysEXT?$AA@ DB 'glUnlockArraysEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FALFDEFM@glLockArraysEXT?$AA@
CONST	SEGMENT
??_C@_0BA@FALFDEFM@glLockArraysEXT?$AA@ DB 'glLockArraysEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NGGABOKH@EXT_compiled_vertex_array?5is?5not@
CONST	SEGMENT
??_C@_0DK@NGGABOKH@EXT_compiled_vertex_array?5is?5not@ DB 'EXT_compiled_v'
	DB	'ertex_array is not supported on this device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LBNKGIPJ@GL_EXT_compiled_vertex_array?$AA@
CONST	SEGMENT
??_C@_0BN@LBNKGIPJ@GL_EXT_compiled_vertex_array?$AA@ DB 'GL_EXT_compiled_'
	DB	'vertex_array', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HILEJHGE@glFogCoordfEXT?$AA@
CONST	SEGMENT
??_C@_0P@HILEJHGE@glFogCoordfEXT?$AA@ DB 'glFogCoordfEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB?$AA@
CONST	SEGMENT
??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB?$AA@ DB 'glClientActiveTextur'
	DB	'eARB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB?$AA@
CONST	SEGMENT
??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB?$AA@ DB 'glMultiTexCoord2fARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKCKKKNH@glActiveTextureARB?$AA@
CONST	SEGMENT
??_C@_0BD@IKCKKKNH@glActiveTextureARB?$AA@ DB 'glActiveTextureARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FCDBIGHN@ARB_multitexture?5is?5not?5supporte@
CONST	SEGMENT
??_C@_0DB@FCDBIGHN@ARB_multitexture?5is?5not?5supporte@ DB 'ARB_multitext'
	DB	'ure is not supported on this device', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MEMOPMEA@GL_ARB_multitexture?$AA@
CONST	SEGMENT
??_C@_0BE@MEMOPMEA@GL_ARB_multitexture?$AA@ DB 'GL_ARB_multitexture', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?InitExtensions@@YAXXZ
_TEXT	SEGMENT
?InitExtensions@@YAXXZ PROC				; InitExtensions, COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 304  : 	// multi-texture
; 305  : 	if (!isExtensionSupported("GL_ARB_multitexture"))

	push	OFFSET ??_C@_0BE@MEMOPMEA@GL_ARB_multitexture?$AA@
	call	?isExtensionSupported@@YAHPBD@Z		; isExtensionSupported
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@InitExtens

; 306  : 		MessageBox(0, "ARB_multitexture is not supported on this device", "error", 0);

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_05KKCIMGE@error?$AA@
	push	OFFSET ??_C@_0DB@FCDBIGHN@ARB_multitexture?5is?5not?5supporte@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@InitExtens:

; 307  : 
; 308  : 	glActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC) wglGetProcAddress("glActiveTextureARB");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@IKCKKKNH@glActiveTextureARB?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glActiveTextureARB@@3P6GXI@ZA, eax ; glActiveTextureARB

; 309  : 	glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC) wglGetProcAddress("glMultiTexCoord2fARB");

	mov	esi, esp
	push	OFFSET ??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glMultiTexCoord2fARB@@3P6GXIMM@ZA, eax ; glMultiTexCoord2fARB

; 310  : 	glClientActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC) wglGetProcAddress("glClientActiveTextureARB");

	mov	esi, esp
	push	OFFSET ??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glClientActiveTextureARB@@3P6GXI@ZA, eax ; glClientActiveTextureARB

; 311  : 	glFogCoordfEXT = (PFNGLFOGCOORDFEXTPROC) wglGetProcAddress("glFogCoordfEXT");

	mov	esi, esp
	push	OFFSET ??_C@_0P@HILEJHGE@glFogCoordfEXT?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glFogCoordfEXT@@3P6GXM@ZA, eax ; glFogCoordfEXT

; 312  : 
; 313  : 	// compiled-vertex-arrays
; 314  : 	if (!isExtensionSupported("GL_EXT_compiled_vertex_array"))

	push	OFFSET ??_C@_0BN@LBNKGIPJ@GL_EXT_compiled_vertex_array?$AA@
	call	?isExtensionSupported@@YAHPBD@Z		; isExtensionSupported
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@InitExtens

; 315  : 		MessageBox(0, "EXT_compiled_vertex_array is not supported on this device", "error", 0);

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_05KKCIMGE@error?$AA@
	push	OFFSET ??_C@_0DK@NGGABOKH@EXT_compiled_vertex_array?5is?5not@
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@InitExtens:

; 316  : 
; 317  : 	glLockArraysEXT = (PFNGLLOCKARRAYSEXTPROC) wglGetProcAddress("glLockArraysEXT");

	mov	esi, esp
	push	OFFSET ??_C@_0BA@FALFDEFM@glLockArraysEXT?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glLockArraysEXT@@3P6GXHH@ZA, eax ; glLockArraysEXT

; 318  : 	glUnlockArraysEXT = (PFNGLUNLOCKARRAYSEXTPROC) wglGetProcAddress("glUnlockArraysEXT");

	mov	esi, esp
	push	OFFSET ??_C@_0BC@CIFHOEOG@glUnlockArraysEXT?$AA@
	call	DWORD PTR __imp__wglGetProcAddress@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?glUnlockArraysEXT@@3P6GXXZA, eax ; glUnlockArraysEXT

; 319  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitExtensions@@YAXXZ ENDP				; InitExtensions
_TEXT	ENDS
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	?ProcessKey@@YA_NPAUHWND__@@I@Z:PROC		; ProcessKey
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__wglDeleteContext@4:PROC
EXTRN	?appShutdown@@YAXXZ:PROC			; appShutdown
EXTRN	__imp__wglMakeCurrent@8:PROC
EXTRN	__imp__wglCreateContext@4:PROC
_BSS	SEGMENT
	ALIGN	4

?hRC@?1??OGLCProc@@YGJPAUHWND__@@IIJ@Z@4PAUHGLRC__@@A DD 01H DUP (?) ; `OGLCProc'::`2'::hRC
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT ?OGLCProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?OGLCProc@@YGJPAUHWND__@@IIJ@Z PROC			; OGLCProc, COMDAT

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 324  :   // Keep drawing stuff around.
; 325  :   static HGLRC hRC;
; 326  : 
; 327  :   switch( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	ja	SHORT $LN17@OGLCProc
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	je	$LN7@OGLCProc
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN12@OGLCProc
	cmp	DWORD PTR tv64[ebp], 2
	je	$LN10@OGLCProc
	cmp	DWORD PTR tv64[ebp], 5
	je	$LN8@OGLCProc
	jmp	$LN1@OGLCProc
$LN17@OGLCProc:
	cmp	DWORD PTR tv64[ebp], 257		; 00000101H
	je	$LN5@OGLCProc
	cmp	DWORD PTR tv64[ebp], 275		; 00000113H
	je	$LN3@OGLCProc
	jmp	$LN1@OGLCProc
$LN12@OGLCProc:

; 328  :   {
; 329  :   case WM_CREATE:
; 330  :     // Remember our mSloth drawing context.
; 331  :     hDC = GetDC( hWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hDC@@3PAUHDC__@@A, eax	; hDC

; 332  : 
; 333  :       if( oglcFullscreen )

	movzx	eax, BYTE PTR _oglcFullscreen
	test	eax, eax
	je	SHORT $LN11@OGLCProc

; 334  :       {
; 335  :         ChangeDisplayMode();

	call	?ChangeDisplayMode@@YA_NXZ		; ChangeDisplayMode
$LN11@OGLCProc:

; 336  :       }
; 337  : 
; 338  :         // Select our precious pixel format.
; 339  :       SetDCPixelFormat( hDC );

	mov	eax, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	eax
	call	?SetDCPixelFormat@@YAXPAUHDC__@@@Z	; SetDCPixelFormat
	add	esp, 4

; 340  : 
; 341  :       // Yeppers, make something that OpenGL understands.
; 342  :       hRC = wglCreateContext( hDC );

	mov	esi, esp
	mov	eax, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	eax
	call	DWORD PTR __imp__wglCreateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hRC@?1??OGLCProc@@YGJPAUHWND__@@IIJ@Z@4PAUHGLRC__@@A, eax

; 343  :       wglMakeCurrent( hDC, hRC );

	mov	esi, esp
	mov	eax, DWORD PTR ?hRC@?1??OGLCProc@@YGJPAUHWND__@@IIJ@Z@4PAUHGLRC__@@A
	push	eax
	mov	ecx, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	ecx
	call	DWORD PTR __imp__wglMakeCurrent@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 344  : 
; 345  : 	  // opengl-extensions
; 346  : 	  InitExtensions();

	call	?InitExtensions@@YAXXZ			; InitExtensions

; 347  : 
; 348  :     ReleaseDC( hWnd, hDC );

	mov	esi, esp
	mov	eax, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 349  :     break;

	jmp	$LN13@OGLCProc
$LN10@OGLCProc:

; 350  : 
; 351  :   case WM_DESTROY:
; 352  :     // Nuke all applicable scene stuff.
; 353  :     appShutdown();

	call	?appShutdown@@YAXXZ			; appShutdown

; 354  :     bReady = false;

	mov	BYTE PTR _bReady, 0

; 355  : 
; 356  :     // Finally release all display context material from OpenGL.
; 357  :     hDC = GetDC( hWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?hDC@@3PAUHDC__@@A, eax	; hDC

; 358  :       wglMakeCurrent( hDC, NULL );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	eax
	call	DWORD PTR __imp__wglMakeCurrent@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 359  :       wglDeleteContext( hRC );

	mov	esi, esp
	mov	eax, DWORD PTR ?hRC@?1??OGLCProc@@YGJPAUHWND__@@IIJ@Z@4PAUHGLRC__@@A
	push	eax
	call	DWORD PTR __imp__wglDeleteContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 360  :     ReleaseDC( hWnd, hDC );

	mov	esi, esp
	mov	eax, DWORD PTR ?hDC@@3PAUHDC__@@A	; hDC
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 361  : 
; 362  :     if( oglcFullscreen )

	movzx	eax, BYTE PTR _oglcFullscreen
	test	eax, eax
	je	SHORT $LN9@OGLCProc

; 363  :     {
; 364  :       RestoreDisplayMode();

	call	?RestoreDisplayMode@@YAXXZ		; RestoreDisplayMode
$LN9@OGLCProc:

; 365  :     }
; 366  : 
; 367  :     PostQuitMessage( 0 );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__PostQuitMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 368  :     break;

	jmp	$LN13@OGLCProc
$LN8@OGLCProc:

; 369  : 
; 370  :   case WM_SIZE:
; 371  :     sys_glWidth = LOWORD(lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	mov	DWORD PTR ?sys_glWidth@@3KA, ecx	; sys_glWidth

; 372  :     sys_glHeight = HIWORD(lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	mov	DWORD PTR ?sys_glHeight@@3KA, ecx	; sys_glHeight

; 373  :     ChangeSize( sys_glWidth, sys_glHeight );

	mov	eax, DWORD PTR ?sys_glHeight@@3KA	; sys_glHeight
	push	eax
	mov	ecx, DWORD PTR ?sys_glWidth@@3KA	; sys_glWidth
	push	ecx
	call	?ChangeSize@@YAXHH@Z			; ChangeSize
	add	esp, 8

; 374  :     break;

	jmp	$LN13@OGLCProc
$LN7@OGLCProc:

; 375  : 
; 376  :   case WM_KEYDOWN:
; 377  : 	  if ((wParam >= 0) && (wParam <= 255))

	cmp	DWORD PTR _wParam$[ebp], 0
	jb	SHORT $LN6@OGLCProc
	cmp	DWORD PTR _wParam$[ebp], 255		; 000000ffH
	ja	SHORT $LN6@OGLCProc

; 378  : 	  {
; 379  : 		kbrd.KeyDown[wParam] = true;

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	BYTE PTR ?kbrd@@3UKeyboard@@A[eax], 1

; 380  : 		ProcessKey(hWnd, wParam);

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	?ProcessKey@@YA_NPAUHWND__@@I@Z		; ProcessKey
	add	esp, 8
$LN6@OGLCProc:

; 381  : 	  }
; 382  :   break;

	jmp	SHORT $LN13@OGLCProc
$LN5@OGLCProc:

; 383  : 
; 384  :   case WM_KEYUP:
; 385  : 	  if ((wParam >= 0) && (wParam <= 255))

	cmp	DWORD PTR _wParam$[ebp], 0
	jb	SHORT $LN4@OGLCProc
	cmp	DWORD PTR _wParam$[ebp], 255		; 000000ffH
	ja	SHORT $LN4@OGLCProc

; 386  : 	  {
; 387  : 		kbrd.KeyDown[wParam] = false;

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	BYTE PTR ?kbrd@@3UKeyboard@@A[eax], 0
$LN4@OGLCProc:

; 388  : 	  }
; 389  :   break;

	jmp	SHORT $LN13@OGLCProc
$LN3@OGLCProc:

; 390  : 
; 391  :   case WM_TIMER:
; 392  :     if((wParam == TIMER_CODE ) && (bReady))

	cmp	DWORD PTR _wParam$[ebp], 123		; 0000007bH
	jne	SHORT $LN2@OGLCProc
	movzx	eax, BYTE PTR _bReady
	test	eax, eax
	je	SHORT $LN2@OGLCProc

; 393  :     {
; 394  :       SetWindowText(hWnd, appGetTitleBar() );

	call	?appGetTitleBar@@YAPADXZ		; appGetTitleBar
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SetWindowTextA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@OGLCProc:

; 395  :     }
; 396  :     break;

	jmp	SHORT $LN13@OGLCProc
$LN1@OGLCProc:

; 397  : 
; 398  : 
; 399  :   default:
; 400  :     return DefWindowProc( hWnd, uMsg, wParam, lParam );

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN15@OGLCProc
$LN13@OGLCProc:

; 401  :   }
; 402  : 
; 403  :   return 0;

	xor	eax, eax
$LN15@OGLCProc:

; 404  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?OGLCProc@@YGJPAUHWND__@@IIJ@Z ENDP			; OGLCProc
_TEXT	ENDS
END
