; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\User\Desktop\ComputerGraphicsProject\Viewer\IOFile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0IOFile@@QAE@XZ				; IOFile::IOFile
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\users\user\desktop\computergraphicsproject\viewer\iofile.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0IOFile@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0IOFile@@QAE@XZ PROC					; IOFile::IOFile, COMDAT
; _this$ = ecx

; 7    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8    :   m_pFile = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 9    :   m_bEOF = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 10   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IOFile@@QAE@XZ ENDP					; IOFile::IOFile
_TEXT	ENDS
PUBLIC	?Free@IOFile@@QAEXXZ				; IOFile::Free
PUBLIC	??1IOFile@@QAE@XZ				; IOFile::~IOFile
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1IOFile@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1IOFile@@QAE@XZ PROC					; IOFile::~IOFile, COMDAT
; _this$ = ecx

; 13   : {Free();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@IOFile@@QAEXXZ			; IOFile::Free
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1IOFile@@QAE@XZ ENDP					; IOFile::~IOFile
_TEXT	ENDS
PUBLIC	?Create@IOFile@@QAE_NPAD0@Z			; IOFile::Create
EXTRN	_fopen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Create@IOFile@@QAE_NPAD0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_szFilename$ = 8					; size = 4
_szMode$ = 12						; size = 4
?Create@IOFile@@QAE_NPAD0@Z PROC			; IOFile::Create, COMDAT
; _this$ = ecx

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 17   :   Free(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@IOFile@@QAEXXZ			; IOFile::Free

; 18   : 
; 19   :   m_pFile = fopen( szFilename, szMode );

	mov	eax, DWORD PTR _szMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFilename$[ebp]
	push	ecx
	call	_fopen
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 20   : 
; 21   :   if( m_pFile )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Create

; 22   :   {
; 23   :     m_bEOF = false; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 24   :     return true;

	mov	al, 1
	jmp	SHORT $LN2@Create
$LN1@Create:

; 25   :   }
; 26   : 
; 27   :   return false;

	xor	al, al
$LN2@Create:

; 28   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@IOFile@@QAE_NPAD0@Z ENDP			; IOFile::Create
_TEXT	ENDS
EXTRN	_fclose:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Free@IOFile@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Free@IOFile@@QAEXXZ PROC				; IOFile::Free, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   :   if( m_pFile )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Free

; 33   :   {
; 34   :     fclose( m_pFile );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fclose
	add	esp, 4

; 35   :     m_pFile = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 36   :     m_bEOF = true; // No more file data, aka EOF.

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1
$LN2@Free:

; 37   :   }
; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Free@IOFile@@QAEXXZ ENDP				; IOFile::Free
_TEXT	ENDS
PUBLIC	?GetPosition@IOFile@@QAEJXZ			; IOFile::GetPosition
EXTRN	_ftell:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetPosition@IOFile@@QAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPosition@IOFile@@QAEJXZ PROC			; IOFile::GetPosition, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   :   return ftell( m_pFile );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_ftell
	add	esp, 4

; 44   : } 

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@IOFile@@QAEJXZ ENDP			; IOFile::GetPosition
_TEXT	ENDS
PUBLIC	?Read@IOFile@@QAE_NPAXK@Z			; IOFile::Read
EXTRN	_feof:PROC
EXTRN	_fread:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Read@IOFile@@QAE_NPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?Read@IOFile@@QAE_NPAXK@Z PROC				; IOFile::Read, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   :   if( m_pFile == 0 ) return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Read
	xor	al, al
	jmp	SHORT $LN6@Read
$LN5@Read:

; 50   :   if( fread( buffer, length, 1, m_pFile ) == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN4@Read

; 51   :   { // Returning with no problem.
; 52   :     return true;

	mov	al, 1
	jmp	SHORT $LN6@Read

; 53   :   } else

	jmp	SHORT $LN3@Read
$LN4@Read:

; 54   :   { // Find out if we failed to read due to EOF condition.
; 55   :     if( feof( m_pFile ) != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_feof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Read

; 56   :       m_bEOF = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 57   :     else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 58   :       m_bEOF = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0
$LN1@Read:

; 59   : 
; 60   :     // Returning with file reading failure.
; 61   :     return false;

	xor	al, al
	jmp	SHORT $LN6@Read
$LN3@Read:

; 62   :   }
; 63   : 
; 64   :   // Some compilers are just plain stupid... :)
; 65   :   //  They don't detect that all branches already return a value.
; 66   :   return true;

	mov	al, 1
$LN6@Read:

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Read@IOFile@@QAE_NPAXK@Z ENDP				; IOFile::Read
_TEXT	ENDS
PUBLIC	?Write@IOFile@@QAE_NPAXK@Z			; IOFile::Write
EXTRN	_fwrite:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Write@IOFile@@QAE_NPAXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?Write@IOFile@@QAE_NPAXK@Z PROC				; IOFile::Write, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   :   if( m_pFile == 0 ) return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@Write
	xor	al, al
	jmp	SHORT $LN3@Write
$LN2@Write:

; 73   :   if( fwrite( buffer, length, 1, m_pFile ) == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	1
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	SHORT $LN1@Write

; 74   :   { // Returning with no problem.
; 75   :     return true;

	mov	al, 1
	jmp	SHORT $LN3@Write
$LN1@Write:

; 76   :   }
; 77   : 
; 78   :   // Returning with file writing failure.
; 79   :   return false;

	xor	al, al
$LN3@Write:

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@IOFile@@QAE_NPAXK@Z ENDP				; IOFile::Write
_TEXT	ENDS
PUBLIC	?SeekFromStart@IOFile@@QAE_NJ@Z			; IOFile::SeekFromStart
EXTRN	_fseek:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SeekFromStart@IOFile@@QAE_NJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_length$ = 8						; size = 4
?SeekFromStart@IOFile@@QAE_NJ@Z PROC			; IOFile::SeekFromStart, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   :   if( fseek( m_pFile, length, SEEK_SET ) == 0 )

	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SeekFromSt

; 85   :     return true;

	mov	al, 1
	jmp	SHORT $LN2@SeekFromSt
$LN1@SeekFromSt:

; 86   : 
; 87   :   return false;

	xor	al, al
$LN2@SeekFromSt:

; 88   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SeekFromStart@IOFile@@QAE_NJ@Z ENDP			; IOFile::SeekFromStart
_TEXT	ENDS
PUBLIC	?SeekFromHere@IOFile@@QAE_NJ@Z			; IOFile::SeekFromHere
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SeekFromHere@IOFile@@QAE_NJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_length$ = 8						; size = 4
?SeekFromHere@IOFile@@QAE_NJ@Z PROC			; IOFile::SeekFromHere, COMDAT
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   :   if( fseek( m_pFile, length, SEEK_CUR ) == 0 )

	push	1
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SeekFromHe

; 93   :     return true;

	mov	al, 1
	jmp	SHORT $LN2@SeekFromHe
$LN1@SeekFromHe:

; 94   : 
; 95   :   return false;

	xor	al, al
$LN2@SeekFromHe:

; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SeekFromHere@IOFile@@QAE_NJ@Z ENDP			; IOFile::SeekFromHere
_TEXT	ENDS
PUBLIC	?SeekFromEnd@IOFile@@QAE_NJ@Z			; IOFile::SeekFromEnd
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SeekFromEnd@IOFile@@QAE_NJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_length$ = 8						; size = 4
?SeekFromEnd@IOFile@@QAE_NJ@Z PROC			; IOFile::SeekFromEnd, COMDAT
; _this$ = ecx

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  :   if( fseek( m_pFile, length, SEEK_END ) == 0 )

	push	2
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SeekFromEn

; 101  :     return true;

	mov	al, 1
	jmp	SHORT $LN2@SeekFromEn
$LN1@SeekFromEn:

; 102  : 
; 103  :   return false;

	xor	al, al
$LN2@SeekFromEn:

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SeekFromEnd@IOFile@@QAE_NJ@Z ENDP			; IOFile::SeekFromEnd
_TEXT	ENDS
END
